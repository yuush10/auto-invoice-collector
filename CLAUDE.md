# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

**Project:** Auto Invoice Collector - Automated invoice and receipt collection system

**Purpose:** Automatically collect invoices and receipts from Gmail, extract metadata via OCR, and organize them in Google Drive with proper naming and folder structure.

**Technology Stack:**
- Runtime: Google Apps Script (V8)
- Language: TypeScript (transpiled to JavaScript)
- Build: Rollup
- Testing: Jest
- OCR/AI: Gemini API (gemini-1.5-flash)
- Development: clasp CLI

**Current Status:** Phase 4.3 Complete (Journal Entry Review Web App)
- Gmail search and PDF attachment extraction
- Gemini OCR for service name and billing month extraction
- Google Drive organization by year-month folders
- Processing log with duplicate detection
- Error notification system
- Email body to PDF conversion via Cloud Run (Phase 2)
- **Journal entry auto-generation** via Gemini AI (Phase 4)
- **Review Web App** for journal confirmation and approval
- **Audit trail** for é›»å­å¸³ç°¿ä¿å­˜æ³• compliance

This document provides guidelines for AI assistants working on this codebase, focusing on GAS-specific development practices and workflows.

## Critical Rules

### 0. Development Workflow Requirements

**ALWAYS follow this workflow before starting any work:**

1. **Check GitHub Issues First**
   ```bash
   # Review open issues to understand current project status
   gh issue list

   # Check specific issue details
   gh issue view <issue-number>
   ```

2. **Create GitHub Issue Before Coding**
   - For new features, bug fixes, or significant changes
   - Document requirements, acceptance criteria, and context
   - Use appropriate labels (enhancement, bug, documentation, etc.)
   - Example:
   ```bash
   gh issue create --title "Add email notification for processing errors" \
     --body "Description and acceptance criteria..." \
     --label "enhancement"
   ```

3. **Create Feature Branch Before Any File Creation/Modification**
   ```bash
   # ALWAYS create a branch before making changes
   git checkout -b feature/description
   # OR
   git checkout -b fix/description
   # OR
   git checkout -b docs/description
   ```

4. **Close Issues via Commits**
   - Reference issue numbers in commit messages
   - Use closing keywords: Closes #N, Fixes #N, Resolves #N
   - Example:
   ```bash
   git commit -m "feat: add error notification system

   Implement email notifications for processing errors.

   Closes #3"
   ```

5. **Create PR and Get Approval**
   - **NEVER merge locally and push to main**
   - Always create PR via CLI and merge through GitHub
   - See Git Workflow section below for details

### 1. Attribution & Commit Messages
**NEVER include AI references in:**
- Commit messages
- Pull request titles/descriptions
- Code comments
- Documentation

âŒ **Prohibited:**
```bash
git commit -m "feat: Add feature (Generated by Claude)"
git commit -m "fix: Bug fix ğŸ¤– AI-assisted"
// Claude: This function handles...
```

âœ… **Required:**
```bash
git commit -m "feat: Add calendar sync functionality"
git commit -m "fix: Resolve timezone conversion errors"
// Initialize Calendar API with error handling
```

### 2. Git Workflow

**IMPORTANT:** Always create feature branches before any file modifications. Never work directly on main.

```bash
# 1. Start new work - Create feature branch
git checkout main && git pull
git checkout -b feature/description

# 2. Make changes and commit
git add .
git commit -m "type(scope): description

Detailed description of changes.

Closes #N"

# 3. Push to remote
git push origin feature/description

# 4. Create PR via CLI (NOT on GitHub webpage)
gh pr create --title "Feature: Description" \
  --body "## Changes
- Change 1
- Change 2

## Related
Closes #N" \
  --base main

# 5. Merge PR via CLI (after approval)
# Get PR number from previous command or use:
gh pr list
gh pr merge <PR-number> --squash --delete-branch

# 6. Cleanup after merge
git checkout main && git pull
git branch -d feature/description      # Delete local branch
git push origin --delete feature/description  # Delete remote branch (if not auto-deleted)
git fetch --prune                      # Clean up remote tracking branches
```

**Branch Naming:**
- `feature/` - New features
- `fix/` - Bug fixes
- `docs/` - Documentation
- `refactor/` - Code refactoring
- `test/` - Test additions

**PR Best Practices:**
- Always create PR via `gh pr create`
- Include clear title and description
- Reference related issues with `Closes #N`
- Merge via `gh pr merge` with `--squash` flag
- Use `--delete-branch` to auto-cleanup remote branch
- Always run `git fetch --prune` after merging to clean up stale remote-tracking branches
- Never use `git merge` locally and push to main

### 2.1 Multi-Phase Development (Development Branches)

For large features spanning multiple sub-issues (like Phase 4 with 5 sub-issues), use a **development branch** to isolate work from main until the entire phase is complete and tested.

**Why Use Development Branches:**
- **Easy rollback**: If the phase fails midway, main remains unaffected
- **Integration testing**: Test all sub-features together before main merge
- **Stable main**: Production code stays reliable
- **Clear history**: Single merge commit for the entire phase

**Branch Structure:**
```
main (stable, production-ready)
  â””â”€â”€ develop/phase-name (integration branch)
        â”œâ”€â”€ feature/phase-name.1-description
        â”œâ”€â”€ feature/phase-name.2-description
        â”œâ”€â”€ feature/phase-name.3-description
        â””â”€â”€ ...
```

**Workflow:**

```bash
# 1. Create development branch from main (once per phase)
git checkout main && git pull
git checkout -b develop/phase4
git push origin develop/phase4 -u

# 2. For each sub-issue, branch from develop branch
git checkout develop/phase4 && git pull
git checkout -b feature/phase4.1-infrastructure

# 3. Make changes and commit
git add .
git commit -m "feat(phase4.1): description

Closes #33"

# 4. Push and create PR targeting develop branch (NOT main)
git push origin feature/phase4.1-infrastructure
gh pr create --base develop/phase4 \
  --title "[Phase 4.1] Feature Description" \
  --body "..."

# 5. After PR approval, merge to develop branch
gh pr merge <PR-number> --squash --delete-branch

# 5.5. IMPORTANT: Manually close the issue (GitHub doesn't auto-close for non-main branches)
gh issue close <issue-number> --comment "Completed in PR #<PR-number>, merged to develop/phase4"

# 6. Repeat steps 2-5.5 for each sub-issue

# 7. After ALL sub-issues complete and tested, merge develop to main
git checkout develop/phase4 && git pull
gh pr create --base main --head develop/phase4 \
  --title "Phase 4: Complete Feature Name" \
  --body "Merges all Phase 4 sub-issues..."

# 8. After final PR approval
gh pr merge <PR-number> --squash

# 9. Cleanup
git checkout main && git pull
git branch -d develop/phase4
git push origin --delete develop/phase4
git fetch --prune                      # Always prune stale remote-tracking branches
```

**IMPORTANT: Manual Issue Closing Required**

GitHub only auto-closes issues when PRs merge to the DEFAULT branch (usually `main`). When merging to development branches, you MUST manually close issues using `gh issue close` as shown in step 5.5 above.

**When to Use:**
- Phases with 3+ related sub-issues
- Features that require integration testing across components
- High-risk changes where rollback capability is important
- Features with compliance requirements (e.g., é›»å­å¸³ç°¿ä¿å­˜æ³•)

**When NOT to Use:**
- Single-issue features
- Small bug fixes
- Documentation updates
- Independent enhancements

### 3. Commit Message Format
Use conventional commits:
```
type(scope): subject

body (optional)

footer (optional)
```

Types: feat, fix, docs, style, refactor, test, chore

### 4. Subagent Coordination

When delegating work to subagents (parallel Claude instances):

**CRITICAL: Automatic Worktree Creation**

Claude and subagents MUST proactively create worktrees when:
- Multiple concurrent tasks may modify overlapping files
- Delegating work to subagents (always use worktrees)
- Working on a task while another task is in progress in the main directory

Do NOT wait for explicit user request - create worktrees automatically to prevent conflicts.

**Before Delegation:**
1. Create dedicated worktree: `git worktree add ../auto-invoice-collector-{name} -b {branch}`
2. Define clear scope and acceptance criteria
3. Provide worktree path to subagent

**Subagent Responsibilities:**
- Work only within assigned worktree
- Follow all project conventions (this file)
- Run quality checks before completing
- Document decisions in issue comments

**After Subagent Completes:**
1. Review changes in worktree
2. Merge to integration branch if approved
3. Remove worktree: `git worktree remove ../auto-invoice-collector-{name}`

**Implementation Loop:**
```
1. Implementation Agent â†’ writes code
2. Quality Check â†’ validates (build, test, anti-patterns)
3. If issues â†’ fix and repeat step 2
4. All checks pass â†’ proceed to commit
```

### 5. Skill Auto-Invocation

Claude MUST proactively invoke project skills when context matches their descriptions. Do NOT manually execute commands that a skill is designed to handle.

**Project Skills and Trigger Contexts:**

| Skill | Trigger Context | Example |
|-------|-----------------|---------|
| `/quality-check` | Before any commit, after implementation | Use instead of manual `npm test` |
| `/deploy` | When deploying, pushing to GAS, or user says "deploy/push/release" | Use instead of manual `clasp push` |
| `/worktree` | When creating, listing, or removing worktrees | Use instead of manual `git worktree` commands |
| `/vendor-status` | When checking vendor credentials or cookie status | Use for auth status checks |

**Required Behavior:**

1. **Before commits**: Always invoke `/quality-check` skill first
2. **For worktree operations**: Always invoke `/worktree` skill
3. **For deployments**: Always invoke `/deploy` skill
4. **For vendor auth checks**: Invoke `/vendor-status` when relevant

**Why This Matters:**
- Skills contain project-specific logic and checks
- Skills ensure consistent workflows across sessions
- Skills may include steps that manual commands miss

## Google Apps Script Development

### Project Structure

```
auto-invoice-collector/
â”œâ”€â”€ .clasp.json                  # Clasp configuration
â”œâ”€â”€ .claspignore                 # Files to exclude from GAS
â”œâ”€â”€ appsscript.json              # GAS manifest (OAuth scopes, timezone)
â”œâ”€â”€ package.json                 # Node.js dependencies
â”œâ”€â”€ tsconfig.json                # TypeScript configuration
â”œâ”€â”€ rollup.config.mjs            # Rollup bundler configuration
â”œâ”€â”€ jest.config.cjs              # Jest test configuration
â”‚
â”œâ”€â”€ src/                         # Source code (TypeScript)
â”‚   â”œâ”€â”€ main.ts                  # Entry point & triggers
â”‚   â”œâ”€â”€ config.ts                # Service configurations
â”‚   â”‚
â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”œâ”€â”€ gmail/
â”‚   â”‚   â”‚   â”œâ”€â”€ GmailSearcher.ts           # Gmail message search
â”‚   â”‚   â”‚   â””â”€â”€ AttachmentExtractor.ts     # PDF attachment extraction
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ drive/
â”‚   â”‚   â”‚   â”œâ”€â”€ FolderManager.ts           # Drive folder management
â”‚   â”‚   â”‚   â””â”€â”€ FileUploader.ts            # File upload to Drive
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ocr/
â”‚   â”‚   â”‚   â””â”€â”€ GeminiOcrService.ts        # Gemini API OCR integration
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ naming/
â”‚   â”‚   â”‚   â””â”€â”€ FileNamingService.ts       # File naming logic
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ logging/
â”‚   â”‚   â”‚   â””â”€â”€ ProcessingLogger.ts        # Google Sheets logging
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ notifications/
â”‚   â”‚   â”‚   â””â”€â”€ Notifier.ts                # Email notifications
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ journal/                       # Phase 4: Journal entry management
â”‚   â”‚       â”œâ”€â”€ DraftSheetManager.ts       # Draft CRUD operations
â”‚   â”‚       â”œâ”€â”€ DraftHistorySheetManager.ts # Change history tracking
â”‚   â”‚       â”œâ”€â”€ DictionarySheetManager.ts  # Learning dictionary
â”‚   â”‚       â”œâ”€â”€ JournalExtractor.ts        # Invoice data extraction
â”‚   â”‚       â”œâ”€â”€ JournalSuggestionService.ts # Journal entry suggestions
â”‚   â”‚       â”œâ”€â”€ JournalGenerator.ts        # Orchestration service
â”‚   â”‚       â””â”€â”€ PromptService.ts           # Prompt management
â”‚   â”‚
â”‚   â”œâ”€â”€ webapp/                  # Phase 4.3: Review Web App
â”‚   â”‚   â”œâ”€â”€ WebAppApi.ts         # Server-side API for frontend
â”‚   â”‚   â””â”€â”€ types.ts             # Web App type definitions
â”‚   â”‚
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ index.ts             # TypeScript type definitions
â”‚   â”‚   â”œâ”€â”€ journal.ts           # Journal entry types
â”‚   â”‚   â”œâ”€â”€ history.ts           # History tracking types
â”‚   â”‚   â””â”€â”€ prompt.ts            # Prompt configuration types
â”‚   â”‚
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ logger.ts            # Logging utilities
â”‚       â””â”€â”€ dateUtils.ts         # Date manipulation utilities
â”‚
â”œâ”€â”€ test/                        # Jest tests
â”‚   â”œâ”€â”€ dateUtils.test.ts        # Unit tests
â”‚   â””â”€â”€ integration/
â”‚       â””â”€â”€ main.integration.test.ts  # Integration tests
â”‚
â”œâ”€â”€ dist/                        # Build output (generated)
â”‚   â”œâ”€â”€ bundle.js                # Compiled & bundled JavaScript
â”‚   â”œâ”€â”€ index.html               # Web App main page
â”‚   â”œâ”€â”€ dashboard.html           # Dashboard component
â”‚   â”œâ”€â”€ review.html              # Review/detail component
â”‚   â”œâ”€â”€ settings.html            # Settings component
â”‚   â”œâ”€â”€ app.js.html              # Vue.js application
â”‚   â””â”€â”€ style.css.html           # Custom styles
â”‚
â”œâ”€â”€ docs/                        # Documentation
â”‚   â””â”€â”€ E2E_TESTING_CHECKLIST.md
â”‚
â”œâ”€â”€ SPECIFICATION.md             # Technical specification
â”œâ”€â”€ DEPLOYMENT.md                # Deployment guide
â”œâ”€â”€ CLAUDE.md                    # This file
â””â”€â”€ README.md                    # Project overview
```

**Key Files:**
- `src/main.ts`: Contains `main()`, `runManually()`, `setupTrigger()`, `doGet()` and API functions
- `src/config.ts`: Service configurations (Gmail search queries, extraction types)
- `src/webapp/WebAppApi.ts`: Server-side API for Review Web App
- `dist/bundle.js`: Final output pushed to Google Apps Script
- `dist/*.html`: Web App HTML files pushed to Google Apps Script
- `appsscript.json`: OAuth scopes and GAS configuration

### Code Style for Apps Script
- Use modern JavaScript features (ES6+) supported by GAS runtime
- **Functions**: Use camelCase, start with verb (e.g., `getCalendarEvents`, `mirrorEvent`)
- **Constants**: Use UPPER_SNAKE_CASE in Config.js
- **Global variables**: Minimize use, prefer function parameters
- **Comments**: Use JSDoc format for function documentation
- **Error handling**: Always wrap API calls in try-catch blocks
- **Logging**: Use `Logger.log()` for development, `console.log()` for script execution logs

### Library Development (CRITICAL)

**IMPORTANT:** GAS libraries MUST use top-level function declarations. IIFE patterns do not work correctly:

âœ… **Correct (Top-level functions):**
```javascript
// CalendarEventHandler.js
function sync(config) {
  // Implementation
}

function mirrorEvent(srcEvent, targetCalendarId, options) {
  // Implementation
}
```

âŒ **INCORRECT (IIFE - does not work in GAS libraries):**
```javascript
var CalendarEventHandler = (function() {
  function sync(config) { /* ... */ }
  return { sync: sync };
})();
```

**Why:** While IIFE syntax is valid JavaScript and runs in GAS, library functions wrapped in IIFE are not properly exposed to consuming projects. Only top-level function declarations are accessible when a project includes the library.

**Library Usage in Applications:**
```javascript
// In consuming project's appsscript.json
{
  "dependencies": {
    "libraries": [{
      "userSymbol": "CalendarEventHandler",
      "libraryId": "1xwM-WneWIb4pqJ7ogiT3daiUVNeuuBnR6Ci_SlUBm3T7K8w8gEFHMLxs",
      "version": "0",
      "developmentMode": true
    }]
  }
}

// Then call library functions with the userSymbol prefix
CalendarEventHandler.sync(config);
CalendarEventHandler.mirrorEvent(event, calendarId, options);
```

### Apps Script Specific Guidelines

#### Working with Calendar API
```javascript
// Get calendar by ID
const calendar = CalendarApp.getCalendarById(calendarId);

// Handle timezone conversions explicitly
const startTime = new Date(event.start.dateTime);
const timeZone = calendar.getTimeZone();

// Batch operations when possible
const events = calendar.getEvents(startDate, endDate);
```

#### Properties Service for Configuration
```javascript
// Store configuration in Script Properties
const scriptProps = PropertiesService.getScriptProperties();
scriptProps.setProperty('SOURCE_CALENDAR_ID', 'calendar@example.com');

// Use User Properties for user-specific data
const userProps = PropertiesService.getUserProperties();
```

#### Triggers
```javascript
// Time-based trigger setup
function createTimeDrivenTrigger() {
  ScriptApp.newTrigger('mirrorEvents')
    .timeBased()
    .everyHours(1)
    .create();
}

// Event-based trigger
function onCalendarUpdate(e) {
  // Handle calendar change event
}
```

#### Error Handling
```javascript
function safeApiCall(operation) {
  try {
    return operation();
  } catch (error) {
    console.error('Error: ' + error.message);
    Logger.log('Stack trace: ' + error.stack);
    // Notify admin or log to external service
    return null;
  }
}
```

### Development Workflow

#### Local Development with Clasp
```bash
# Install clasp globally (if not already installed)
npm install -g @google/clasp

# Login to Google account
clasp login

# Clone existing project
clasp clone <scriptId>

# Pull latest changes from Apps Script
clasp pull

# Push local changes to Apps Script
clasp push

# Open project in Apps Script editor
clasp open-script

# View logs
clasp tail-logs
```

#### Testing
```javascript
// Create test functions with "test" prefix
function testMirrorEvent() {
  const testEvent = {
    summary: 'Test Event',
    start: { dateTime: new Date().toISOString() },
    end: { dateTime: new Date(Date.now() + 3600000).toISOString() }
  };

  const result = mirrorEvent(testEvent);
  Logger.log('Test result: ' + JSON.stringify(result));
}

// Run tests manually in Apps Script editor or via clasp
```

#### Deployment
```bash
# Create a new version
clasp version "Description of changes"

# Deploy as web app or API executable
clasp deploy --description "Production deployment"

# List deployments
clasp deployments
```

### Performance Considerations
- **Execution time limits**: GAS scripts timeout after 6 minutes (consumer) or 30 minutes (Workspace)
- **API quotas**: Calendar API has daily quotas (check Google Cloud Console)
- **Batch operations**: Group API calls to minimize execution time
- **Caching**: Use CacheService for frequently accessed data
```javascript
const cache = CacheService.getScriptCache();
cache.put('key', 'value', 21600); // Cache for 6 hours
```

### Security Best Practices
- **OAuth Scopes**: Declare minimal required scopes in appsscript.json
- **API Keys**: Use Script Properties, never hardcode
- **Calendar IDs**: Store in Properties Service
- **Validate inputs**: Check all event data before processing
- **Error messages**: Don't expose sensitive information in logs

### Common Tasks

#### Debugging
1. Use `Logger.log()` liberally during development
2. Check execution transcripts in Apps Script editor (View â†’ Executions)
3. Use `clasp logs` to view recent logs
4. Test edge cases: all-day events, recurring events, timezone differences

## AI Assistant Behavior

### When Writing Code
1. Focus on solving the problem efficiently within GAS constraints
2. Write clean, maintainable JavaScript code
3. Include try-catch blocks for all API calls
4. Add JSDoc comments for public functions
5. Follow GAS-specific conventions (camelCase for functions)

### When Responding
1. Be concise but complete
2. Provide working GAS examples
3. Explain quota and runtime implications
4. Suggest alternatives when appropriate
5. Ask for clarification if needed

### Context Optimization
Given limited context windows:
1. Prioritize relevant GAS documentation
2. Focus on current task
3. Reference Apps Script docs: https://developers.google.com/apps-script
4. Use code snippets judiciously

## Project-Specific Configuration

### appsscript.json for This Project
```json
{
  "timeZone": "Asia/Tokyo",
  "dependencies": {},
  "exceptionLogging": "STACKDRIVER",
  "runtimeVersion": "V8",
  "oauthScopes": [
    "https://www.googleapis.com/auth/gmail.readonly",
    "https://www.googleapis.com/auth/gmail.labels",
    "https://www.googleapis.com/auth/drive.file",
    "https://www.googleapis.com/auth/script.external_request"
  ]
}
```

## GitHub Issue Management

### Checking Project Status

**Before starting work, always check GitHub Issues:**
```bash
# List all open issues
gh issue list

# List issues with specific label
gh issue list --label "enhancement"
gh issue list --label "bug"

# View specific issue details
gh issue view 5

# Search issues
gh issue list --search "notification"
```

### Creating Issues

**Create issues before starting implementation:**
```bash
# Create feature issue
gh issue create \
  --title "Add processing statistics dashboard" \
  --body "## Description
Implement a dashboard to view processing statistics.

## Requirements
- Display daily/weekly/monthly stats
- Show error rates
- Export functionality

## Acceptance Criteria
- [ ] Dashboard accessible via web
- [ ] Stats updated in real-time
- [ ] Export to CSV works" \
  --label "enhancement"

# Create bug issue
gh issue create \
  --title "Fix duplicate file detection" \
  --body "SHA256 hash comparison failing for large files." \
  --label "bug"
```

### Closing Issues

**Close issues via commit messages:**
```bash
# Single issue
git commit -m "feat: add statistics dashboard

Closes #7"

# Multiple issues
git commit -m "fix: improve duplicate detection

Fixes #8, Closes #9"
```

**Or close via CLI:**
```bash
# Close with comment
gh issue close 5 --comment "Implemented in PR #12"

# Reopen if needed
gh issue reopen 5
```

**IMPORTANT: Manual Closing for Development Branch Merges**

GitHub only auto-closes issues when PRs merge to the DEFAULT branch (usually `main`).
When merging to development branches (e.g., `develop/phase4`), you MUST manually close issues:

```bash
gh issue close <issue-number> --comment "Completed in PR #<PR-number>, merged to develop/phase-name"
```

## Quick Reference

### Worktree Workflow

```bash
# Create worktree for parallel development
git worktree add ../auto-invoice-collector-{name} -b feature/{issue}-{description}
cd ../auto-invoice-collector-{name}
npm install

# List active worktrees
git worktree list

# Remove after merge (from main repo)
git worktree remove ../auto-invoice-collector-{name}
```

**Naming Convention:**
- Path: `../auto-invoice-collector-{branch-short-name}`
- Branch: `{type}/{issue-number}-{description}`

### Quality Check Commands

```bash
# Run all quality checks
npx tsc --noEmit && npm test && npm run build

# Individual checks
npx tsc --noEmit    # TypeScript compilation
npm test            # Jest tests
npm run build       # Bundle build
```

### Deploy Commands

```bash
# Standard deploy
npm run build && npm test && clasp push

# Full deploy with version
npm run deploy

# Open in Apps Script editor
clasp open
```

## Remember
The goal is to create a reliable, maintainable invoice collection system that:
- Automatically processes Gmail invoice attachments
- Extracts metadata via Gemini OCR
- Organizes files in Google Drive by year-month
- Maintains processing logs with duplicate detection
- Sends error notifications when issues occur
- **Generates journal entry suggestions via Gemini AI**
- **Provides a Web App for reviewing and approving journal entries**
- **Maintains audit trail for é›»å­å¸³ç°¿ä¿å­˜æ³• compliance**

Always:
1. Check GitHub issues before starting work
2. Create feature branch before any changes
3. Create PR via CLI (`gh pr create`)
4. Reference issues in commits (`Closes #N`)
5. Merge via CLI (`gh pr merge`)
6. Clean up branches after merge